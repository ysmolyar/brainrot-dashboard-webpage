<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Brainrot Ads Dashboard</title>

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="brainrot-icon.png">
  <link rel="apple-touch-icon" href="brainrot-icon.png">

  <!-- Meta tags for better SEO and sharing -->
  <meta name="description" content="Ad metrics dashboard for Brainrot app - track spend, clicks, impressions, and conversions">
  <meta name="author" content="Brainrot">
  <meta name="theme-color" content="#111827">

  <!-- Open Graph tags for social sharing -->
  <meta property="og:title" content="Brainrot Ads Dashboard">
  <meta property="og:description" content="Ad metrics dashboard for Brainrot app">
  <meta property="og:image" content="brainrot-icon.png">
  <meta property="og:type" content="website">

  <!-- Apple specific -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Brainrot">
  <link rel="manifest" href="manifest.json">

  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>

  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #111827;
      color: white;
      padding: 16px;
      min-height: 100vh;
    }
    .container { max-width: 1200px; margin: 0 auto; width: 100%; }

    /* Mobile-specific adjustments */
    @media (max-width: 600px) {
      body { padding: 8px; }
      .container { padding: 0; }
    }
    header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-wrap: wrap; gap: 12px; }
    .main-header { position: relative; }
    .header-icon { position: absolute; left: 0; top: 50%; transform: translateY(-50%); cursor: pointer; }
    .header-title { position: absolute; left: 50%; transform: translateX(-50%); text-align: center; }
    .main-header .controls { margin-left: auto; }
    h1 { font-size: 1.5rem; }
    .updated { font-size: 0.75rem; color: #6B7280; }
    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }

    @media (max-width: 600px) {
      header { gap: 8px; margin-bottom: 16px; }
      .main-header { min-height: 44px; }
      .header-icon { position: absolute; left: 0; top: 50%; transform: translateY(-50%); }
      .header-title { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); }
      .hamburger-menu { top: 50%; transform: translateY(-50%); }
      h1 { font-size: 1.25rem; }
      button, select {
        padding: 6px 10px;
        font-size: 16px;
      }
    }
    button, select {
      background: #374151;
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      -webkit-text-size-adjust: 100%;
    }
    button:hover, select:hover { background: #4B5563; }
    button.active { background: #2563EB; }
    select {
      padding-right: 28px;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg width='8' height='5' viewBox='0 0 8 5' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M1 1L4 4L7 1' stroke='%239CA3AF' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 10px center;
    }

    .cards { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin-bottom: 16px; }
    @media (max-width: 900px) { .cards { grid-template-columns: repeat(3, 1fr); } }
    @media (max-width: 600px) { .cards { grid-template-columns: repeat(2, 1fr); } }
    .card {
      background: #1F2937;
      padding: 12px;
      border-radius: 8px;
    }
    .card-label { font-size: 0.75rem; color: #9CA3AF; }
    .card-value { font-size: 1.5rem; font-weight: bold; }

    @media (max-width: 600px) {
      .card { padding: 8px; }
      .card-value { font-size: 1.25rem; }
      .card-label { font-size: 0.7rem; }
    }
    .red { color: #F87171; }
    .green { color: #4ADE80; }
    .cyan { color: #22D3D3; }
    .blue { color: #60A5FA; }

    .insights-container {
      margin-bottom: 16px;
    }
    .insight {
      background: #1F2937;
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 8px;
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }
    .insight:last-child { margin-bottom: 0; }
    .insight-icon {
      flex-shrink: 0;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }
    .insight-warning .insight-icon { background: rgba(251, 191, 36, 0.2); color: #FBBF24; }
    .insight-danger .insight-icon { background: rgba(248, 113, 113, 0.2); color: #F87171; }
    .insight-success .insight-icon { background: rgba(74, 222, 128, 0.2); color: #4ADE80; }
    .insight-info .insight-icon { background: rgba(96, 165, 250, 0.2); color: #60A5FA; }
    .insight-content { flex: 1; }
    .insight-title {
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 2px;
    }
    .insight-warning .insight-title { color: #FBBF24; }
    .insight-danger .insight-title { color: #F87171; }
    .insight-success .insight-title { color: #4ADE80; }
    .insight-info .insight-title { color: #60A5FA; }
    .insight-description {
      font-size: 0.8rem;
      color: #9CA3AF;
      line-height: 1.4;
    }
    .insights-empty {
      display: none;
    }

    .chart-container {
      background: #1F2937;
      padding: 20px 16px 16px 16px;
      border-radius: 8px;
      margin-bottom: 16px;
      position: relative;
    }

    .chart-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
      gap: 8px;
    }

    .chart-title {
      font-size: 0.875rem;
      color: #9CA3AF;
    }

    .chart-wrapper {
      position: relative;
      height: 280px;
    }

    @media (max-width: 600px) {
      .chart-container {
        padding: 16px 8px 8px 8px;
        border-radius: 4px;
      }
      .chart-wrapper { height: 220px; }
    }

    .chart-selectors {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    .metric-selector {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .metric-selector .color-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .metric-selector select {
      background: #374151;
      color: white;
      border: none;
      padding: 6px 24px 6px 8px;
      border-radius: 4px;
      font-size: 0.8125rem;
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg width='8' height='5' viewBox='0 0 8 5' fill='none' xmlns='http://www.w3.org/2000/svg'%3e%3cpath d='M1 1L4 4L7 1' stroke='%239CA3AF' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 8px center;
    }

    .metric-selector select:hover {
      background-color: #4B5563;
    }

    /* Granularity dropdown */
    .granularity-dropdown {
      position: relative;
    }

    .granularity-btn {
      background: transparent;
      border: none;
      color: white;
      font-size: 0.75rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 4px;
      padding: 4px 8px;
      font-weight: 500;
    }

    .granularity-menu {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      background: #1F2937;
      border: 1px solid #374151;
      border-radius: 4px;
      margin-top: 4px;
      min-width: 100px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      z-index: 50;
    }

    .granularity-menu.open {
      display: block;
    }

    .granularity-option {
      padding: 8px 12px;
      cursor: pointer;
      color: white;
      font-size: 0.75rem;
    }

    .granularity-option:hover {
      background: #374151;
    }

    .granularity-option:not(:last-child) {
      border-bottom: 1px solid #374151;
    }

    .table-container {
      background: #1A202C;
      border-radius: 8px;
      padding: 20px;
      overflow-x: auto;
      margin-bottom: 16px;
    }

    .table-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
    }

    .table-title {
      font-size: 0.875rem;
      color: #9CA3AF;
    }

    #ads-table {
      width: 100%;
      border-collapse: collapse;
    }

    #ads-table th {
      text-align: right;
      padding: 8px 12px;
      color: #9CA3AF;
      font-weight: 500;
      font-size: 0.8125rem;
      border-bottom: 1px solid #374151;
      white-space: nowrap;
    }

    #ads-table th:first-child {
      text-align: left;
    }

    #ads-table td {
      text-align: right;
      padding: 8px 12px;
      color: white;
      font-size: 0.875rem;
      border-bottom: 1px solid #2D3748;
      white-space: nowrap;
    }

    #ads-table td:first-child {
      text-align: left;
      color: #9CA3AF;
    }

    #ads-table tbody tr:hover {
      background: #1F2937;
    }

    #ads-table tfoot td {
      font-weight: 600;
      border-top: 2px solid #374151;
      border-bottom: none;
    }

    @media (max-width: 600px) {
      .table-container {
        zoom: 0.65;
      }
    }

    /* Column config dropdown */
    .column-config {
      position: relative;
    }

    .column-config-btn {
      background: transparent;
      border: 1px solid #374151;
      color: #9CA3AF;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.75rem;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .column-config-btn:hover {
      background: #374151;
      color: white;
    }

    .column-config-menu {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      background: #1F2937;
      border: 1px solid #374151;
      border-radius: 8px;
      margin-top: 4px;
      min-width: 200px;
      max-height: 400px;
      overflow-y: auto;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 100;
      padding: 8px 0;
    }

    .column-config-menu.open {
      display: block;
    }

    .column-config-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      font-size: 0.8125rem;
      cursor: pointer;
      color: white;
    }

    .column-config-item:hover {
      background: #374151;
    }

    .column-config-item input {
      accent-color: #2563EB;
      width: 16px;
      height: 16px;
    }

    /* Dashboard nav dropdown */
    .nav-dropdown {
      position: relative;
      display: inline-block;
    }

    .nav-dropdown-menu {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      background: #1F2937;
      border: 1px solid #374151;
      border-radius: 8px;
      margin-top: 8px;
      min-width: 180px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 100;
      overflow: hidden;
    }

    .nav-dropdown-menu.open {
      display: block;
    }

    .nav-dropdown-item {
      display: block;
      padding: 12px 16px;
      color: white;
      text-decoration: none;
      font-size: 0.875rem;
      border-bottom: 1px solid #374151;
    }

    .nav-dropdown-item:last-child {
      border-bottom: none;
    }

    .nav-dropdown-item:hover {
      background: #374151;
    }

    .nav-dropdown-item.active {
      background: #2563EB;
    }

    /* Hamburger menu for mobile */
    .hamburger-menu {
      display: none;
      position: absolute;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
    }

    @media (max-width: 600px) {
      .hamburger-menu {
        display: block;
        position: absolute;
        right: 0;
        top: 8px;
        transform: none;
      }
      .desktop-controls {
        display: none;
      }
    }

    .hamburger-btn {
      background: transparent;
      border: none;
      padding: 8px;
      cursor: pointer;
      color: white;
    }

    .hamburger-dropdown {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      background: #1F2937;
      border: 1px solid #374151;
      border-radius: 8px;
      margin-top: 4px;
      min-width: 180px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      z-index: 100;
    }

    .hamburger-dropdown.open {
      display: block;
    }

    .menu-section {
      padding: 8px 0;
      border-bottom: 1px solid #374151;
    }

    .menu-section:last-child {
      border-bottom: none;
    }

    .menu-label {
      padding: 4px 16px;
      font-size: 0.7rem;
      color: #6B7280;
      text-transform: uppercase;
    }

    .menu-option {
      padding: 8px 16px;
      font-size: 0.8125rem;
      cursor: pointer;
      color: white;
    }

    .menu-option:hover {
      background: #374151;
    }

    .menu-option.selected {
      background: #2563EB;
    }

    /* Password gate */
    .password-gate {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: #111827;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .password-gate.hidden {
      display: none;
    }

    .password-box {
      background: #1F2937;
      padding: 32px;
      border-radius: 12px;
      text-align: center;
      max-width: 320px;
      width: 90%;
    }

    .password-box h2 {
      margin-bottom: 8px;
      font-size: 1.25rem;
    }

    .password-box p {
      color: #9CA3AF;
      margin-bottom: 20px;
      font-size: 0.875rem;
    }

    .password-box input {
      width: 100%;
      padding: 12px;
      border: 1px solid #374151;
      border-radius: 6px;
      background: #111827;
      color: white;
      font-size: 16px;
      margin-bottom: 12px;
    }

    .password-box button {
      width: 100%;
      padding: 12px;
      background: #2563EB;
      border: none;
      border-radius: 6px;
      color: white;
      font-weight: 500;
      cursor: pointer;
    }

    .password-box button:hover {
      background: #1D4ED8;
    }

    .password-error {
      color: #F87171;
      font-size: 0.8125rem;
      margin-top: 12px;
      display: none;
    }

    .dashboard-content {
      display: none;
    }

    .dashboard-content.visible {
      display: block;
    }

    /* Pull to refresh spinner */
    #ptr-spinner {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      width: 28px;
      height: 28px;
      z-index: 1001;
      pointer-events: none;
      opacity: 0;
      top: -40px;
    }

    #ptr-spinner.visible {
      opacity: 1;
    }

    #ptr-spinner.refreshing svg {
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    /* Dark scrollbar styles */
    ::-webkit-scrollbar {
      height: 8px;
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #1A202C;
    }
    ::-webkit-scrollbar-thumb {
      background: #4A5568;
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #718096;
    }
  </style>
</head>
<body>
  <!-- Pull to refresh spinner -->
  <div id="ptr-spinner">
    <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="#60A5FA" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
      <path d="M23 4v6h-6"></path>
      <path d="M1 20v-6h6"></path>
      <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
    </svg>
  </div>

  <!-- Password Gate -->
  <div class="password-gate" id="password-gate">
    <div class="password-box">
      <h2>Brainrot Ads</h2>
      <p>Enter password to continue</p>
      <form onsubmit="return checkPassword(event)">
        <input type="password" id="password-input" placeholder="Password" autocomplete="current-password">
        <button type="submit">Enter</button>
      </form>
      <div id="password-error" class="password-error">Incorrect password</div>
    </div>
  </div>

  <div class="container dashboard-content" id="dashboard-content">
    <header class="main-header">
      <div class="nav-dropdown">
        <img src="brainrot-icon.png" alt="Brainrot" class="header-icon" style="width: 32px; height: 32px; border-radius: 8px; object-fit: cover;" onclick="toggleNavDropdown()">
        <div class="nav-dropdown-menu" id="nav-dropdown-menu">
          <a href="index.html" class="nav-dropdown-item">Brainrot Summary</a>
          <a href="ads.html" class="nav-dropdown-item active">Brainrot Ads</a>
        </div>
      </div>
      <div class="header-title">
        <h1>Brainrot Ads</h1>
        <div class="updated" id="updated"></div>
      </div>
      <!-- Hamburger menu for mobile -->
      <div class="hamburger-menu">
        <button class="hamburger-btn" onclick="toggleHamburgerMenu()">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="3" y1="6" x2="21" y2="6"></line>
            <line x1="3" y1="12" x2="21" y2="12"></line>
            <line x1="3" y1="18" x2="21" y2="18"></line>
          </svg>
        </button>
        <div id="hamburger-dropdown" class="hamburger-dropdown">
          <div class="menu-section">
            <div class="menu-label">Time Range</div>
            <div class="menu-option" onclick="selectTimeRange('24h')">Last 24 Hours</div>
            <div class="menu-option" onclick="selectTimeRange('today')">Today</div>
            <div class="menu-option" onclick="selectTimeRange('yesterday')">Yesterday</div>
            <div class="menu-option" onclick="selectTimeRange('7d')">Last 7 Days</div>
            <div class="menu-option" onclick="selectTimeRange('14d')">Last 14 Days</div>
            <div class="menu-option" onclick="selectTimeRange('30d')">Last 30 Days</div>
          </div>
          <div class="menu-section">
            <div class="menu-label">Timezone</div>
            <div class="menu-option" onclick="selectTimezone('America/Los_Angeles')">PST</div>
            <div class="menu-option" onclick="selectTimezone('America/New_York')">EST</div>
          </div>
          <div class="menu-section">
            <label class="menu-option" style="display: flex; align-items: center; cursor: pointer;">
              <input type="checkbox" id="boost-toggle-mobile" onchange="toggleBoost(this.checked)" style="margin-right: 8px;">
              Boost Mode
            </label>
          </div>
          <div class="menu-section">
            <div class="menu-option" onclick="fetchData(true); toggleHamburgerMenu();">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px; vertical-align: middle;">
                <path d="M23 4v6h-6"></path>
                <path d="M1 20v-6h6"></path>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
              </svg>
              Refresh
            </div>
          </div>
        </div>
      </div>
      <!-- Desktop controls -->
      <div class="controls desktop-controls">
        <select id="time-range" onchange="handleTimeRangeChange()">
          <option value="24h" selected>Last 24 Hours</option>
          <option value="today">Today</option>
          <option value="yesterday">Yesterday</option>
          <option value="7d">Last 7 Days</option>
          <option value="14d">Last 14 Days</option>
          <option value="30d">Last 30 Days</option>
        </select>
        <select id="timezone" onchange="render()">
          <option value="America/Los_Angeles">PST</option>
          <option value="America/New_York">EST</option>
        </select>
        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 0.875rem; color: #9CA3AF;">
          <input type="checkbox" id="boost-toggle-desktop" onchange="toggleBoost(this.checked)">
          Boost
        </label>
        <button onclick="fetchData(true)" style="padding: 6px 10px; display: flex; align-items: center; justify-content: center;">
          <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M23 4v6h-6"></path>
            <path d="M1 20v-6h6"></path>
            <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
          </svg>
        </button>
      </div>
    </header>

    <div class="cards">
      <div class="card">
        <div class="card-value" id="total-spend">$0</div>
        <div class="card-label">Amount Spent</div>
      </div>
      <div class="card">
        <div class="card-value" id="boost-factor">1.0x</div>
        <div class="card-label">Boost Factor</div>
      </div>
      <div class="card">
        <div class="card-value" id="avg-cpa">$0</div>
        <div class="card-label" id="cpa-label">Cost per Result</div>
      </div>
      <div class="card">
        <div class="card-value" id="avg-roas">0.00</div>
        <div class="card-label" id="roas-label">Real ROAS</div>
      </div>
      <div class="card">
        <div class="card-value" id="avg-ctr">0%</div>
        <div class="card-label">CTR</div>
      </div>
      <div class="card">
        <div class="card-value" id="avg-cpc">$0.00</div>
        <div class="card-label">CPC</div>
      </div>
    </div>

    <div class="insights-container" id="insights-container"></div>

    <div class="chart-container" style="position: relative; padding-top: 40px;">
      <div style="position: absolute; top: 12px; right: 16px; z-index: 10;">
        <div class="granularity-dropdown">
          <button class="granularity-btn" onclick="toggleGranularityDropdown()">
            <span id="granularity-label">Hourly</span>
            <svg width="8" height="5" viewBox="0 0 8 5" fill="none" style="margin-top: 1px;">
              <path d="M1 1L4 4L7 1" stroke="#9CA3AF" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <div class="granularity-menu" id="granularity-menu">
            <div class="granularity-option" onclick="selectGranularity('hourly')">Hourly</div>
            <div class="granularity-option" onclick="selectGranularity('daily')">Daily</div>
          </div>
        </div>
      </div>
      <div class="chart-header">
        <span class="chart-title">Metrics Over Time</span>
        <div class="chart-selectors">
          <div class="metric-selector">
            <span class="color-dot" style="background: #F87171;"></span>
            <select id="chart-metric-left" onchange="updateChart()">
              <option value="spend" selected>Spend</option>
              <option value="cpm">CPM</option>
              <option value="cpc">CPC</option>
              <option value="ctr">CTR</option>
              <option value="cpa">Cost per Result</option>
              <option value="conversions">Results</option>
              <option value="conversion_value">Results Value</option>
              <option value="purchase_roas">Meta ROAS</option>
              <option value="appstore_conv">App Store Conv</option>
              <option value="onboarding_conv">Onboarding Conv</option>
              <option value="impressions">Impressions</option>
              <option value="clicks">Clicks</option>
              <option value="app_installs">App Installs</option>
              <option value="sw_new_proceeds">SW New $</option>
              <option value="sw_renewal_proceeds">SW Renewal $</option>
              <option value="sw_total_proceeds">SW Total $</option>
              <option value="real_roas">Real ROAS</option>
              <option value="real_cpa">Real Cost per Result</option>
              <option value="none">None</option>
            </select>
          </div>
          <div class="metric-selector">
            <span class="color-dot" style="background: #4ADE80;"></span>
            <select id="chart-metric-right" onchange="updateChart()">
              <option value="none">None</option>
              <option value="spend">Spend</option>
              <option value="cpm">CPM</option>
              <option value="cpc">CPC</option>
              <option value="ctr">CTR</option>
              <option value="cpa">Cost per Result</option>
              <option value="conversions">Results</option>
              <option value="conversion_value">Results Value</option>
              <option value="purchase_roas">Meta ROAS</option>
              <option value="appstore_conv">App Store Conv</option>
              <option value="onboarding_conv">Onboarding Conv</option>
              <option value="impressions">Impressions</option>
              <option value="clicks">Clicks</option>
              <option value="app_installs">App Installs</option>
              <option value="sw_new_proceeds">SW New $</option>
              <option value="sw_renewal_proceeds">SW Renewal $</option>
              <option value="sw_total_proceeds">SW Total $</option>
              <option value="real_roas" selected>Real ROAS</option>
              <option value="real_cpa">Real Cost per Result</option>
            </select>
          </div>
        </div>
      </div>
      <div class="chart-wrapper">
        <canvas id="ads-chart"></canvas>
      </div>
    </div>

    <div class="table-container">
      <div class="table-header">
        <span class="table-title">Hourly Ad Metrics</span>
        <div class="column-config">
          <button class="column-config-btn" onclick="toggleColumnConfig()">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 3v18M3 12h18"/>
            </svg>
            Columns
          </button>
          <div class="column-config-menu" id="column-config-menu">
            <!-- Column checkboxes will be generated here -->
          </div>
        </div>
      </div>
      <table id="ads-table">
        <thead>
          <tr id="ads-table-header">
            <!-- Headers will be generated dynamically -->
          </tr>
        </thead>
        <tbody id="ads-tbody">
          <!-- Data rows will be inserted here -->
        </tbody>
        <tfoot>
          <tr id="ads-totals-row">
            <!-- Totals will be generated dynamically -->
          </tr>
        </tfoot>
      </table>
    </div>
  </div>

  <script>
    const SUPABASE_URL = 'https://tuueizexidbuvvgvxpms.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InR1dWVpemV4aWRidXZ2Z3Z4cG1zIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjU4MjM2NjksImV4cCI6MjA4MTM5OTY2OX0.lQ0MVBF98Jvc8qzP4M3W2osRvWQlUuCHeVTajuERi7A';

    let adsData = [];
    let superwallData = [];
    let chart = null;
    let chartData = [];
    let granularity = 'hourly';
    let boostEnabled = localStorage.getItem('brainrot_boost_enabled') !== 'false'; // Default to true

    // All available columns with their display names and formatting
    const ALL_COLUMNS = {
      hour: { label: 'Hour', type: 'time', alwaysShow: true },
      spend: { label: 'Amount Spent', type: 'currency', default: true },
      cpm: { label: 'CPM', type: 'currency', default: true },
      ctr: { label: 'CTR', type: 'percent', default: true },
      cpc: { label: 'CPC', type: 'currency', default: true },
      appstore_conv: { label: 'App Store Conv', type: 'percent', default: true },
      onboarding_conv: { label: 'Onboarding Conv', type: 'percent', default: true },
      cpa: { label: 'Cost per Result', type: 'currency', default: true },
      conversions: { label: 'Results', type: 'number', default: true },
      conversion_value: { label: 'Results Value', type: 'currency', default: true },
      purchase_roas: { label: 'Results ROAS', type: 'decimal', default: true },
      // Superwall columns
      sw_new_proceeds: { label: 'SW New $', type: 'currency', default: false },
      sw_renewal_proceeds: { label: 'SW Renewal $', type: 'currency', default: false },
      sw_total_proceeds: { label: 'SW Total $', type: 'currency', default: false },
      real_roas: { label: 'Real ROAS', type: 'decimal', default: false },
      // Additional columns (hidden by default)
      impressions: { label: 'Impressions', type: 'number', default: false },
      clicks: { label: 'Clicks', type: 'number', default: false },
      reach: { label: 'Reach', type: 'number', default: false },
      frequency: { label: 'Frequency', type: 'decimal', default: false },
      link_clicks: { label: 'Link Clicks', type: 'number', default: false },
      app_installs: { label: 'App Installs', type: 'number', default: false },
      cost_per_install: { label: 'Cost per Install', type: 'currency', default: false }
    };

    // Load visible columns from localStorage or use defaults
    // Version 3: Reset columns to include new Superwall columns
    const COLUMNS_VERSION = 3;
    const storedVersion = localStorage.getItem('ads_columns_version');
    if (storedVersion !== String(COLUMNS_VERSION)) {
      localStorage.removeItem('ads_visible_columns');
      localStorage.setItem('ads_columns_version', COLUMNS_VERSION);
    }
    let visibleColumns = JSON.parse(localStorage.getItem('ads_visible_columns')) ||
      Object.keys(ALL_COLUMNS).filter(k => ALL_COLUMNS[k].default || ALL_COLUMNS[k].alwaysShow);

    function saveVisibleColumns() {
      localStorage.setItem('ads_visible_columns', JSON.stringify(visibleColumns));
    }

    function toggleColumnConfig() {
      const menu = document.getElementById('column-config-menu');
      menu.classList.toggle('open');
      if (menu.classList.contains('open')) {
        renderColumnConfig();
      }
    }

    function renderColumnConfig() {
      const menu = document.getElementById('column-config-menu');
      menu.innerHTML = '';

      Object.entries(ALL_COLUMNS).forEach(([key, col]) => {
        if (col.alwaysShow) return; // Skip hour column

        const item = document.createElement('label');
        item.className = 'column-config-item';
        item.innerHTML = `
          <input type="checkbox" ${visibleColumns.includes(key) ? 'checked' : ''}
                 onchange="toggleColumn('${key}', this.checked)">
          <span>${col.label}</span>
        `;
        menu.appendChild(item);
      });
    }

    function toggleColumn(key, checked) {
      if (checked && !visibleColumns.includes(key)) {
        visibleColumns.push(key);
      } else if (!checked) {
        visibleColumns = visibleColumns.filter(k => k !== key);
      }
      saveVisibleColumns();
      render();
    }

    async function fetchData(forceRefresh = false) {
      const CACHE_KEY = 'brainrot_ads_cache';
      const SUPERWALL_CACHE_KEY = 'brainrot_superwall_cache'; // Shared across pages
      const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes cache

      // Check cache first
      if (!forceRefresh) {
        const cached = localStorage.getItem(CACHE_KEY);
        const superwallCached = localStorage.getItem(SUPERWALL_CACHE_KEY);

        if (cached && superwallCached) {
          const cacheData = JSON.parse(cached);
          const swCache = JSON.parse(superwallCached);
          const cacheAge = Date.now() - cacheData.timestamp;
          const swCacheAge = Date.now() - swCache.timestamp;

          if (cacheAge < CACHE_DURATION && swCacheAge < CACHE_DURATION) {
            adsData = cacheData.adsData;
            superwallData = swCache.data;
            updateSubtitle();
            render();
            return;
          }
        }
      }

      const headers = {
        apikey: SUPABASE_ANON_KEY,
        Authorization: `Bearer ${SUPABASE_ANON_KEY}`,
      };

      try {
        // Fetch all ads data with all metrics
        const fetchAllAds = async () => {
          let allData = [];
          let offset = 0;
          const limit = 1000;

          while (true) {
            const res = await fetch(
              `${SUPABASE_URL}/rest/v1/meta_ads_hourly?select=*&order=hour_utc.asc&limit=${limit}&offset=${offset}`,
              { headers }
            );
            const data = await res.json();
            allData = allData.concat(data);

            if (data.length < limit) break;
            offset += limit;
          }
          return allData;
        };

        // Check if we can use shared Superwall cache
        let needSuperwallFetch = true;
        const superwallCached = localStorage.getItem(SUPERWALL_CACHE_KEY);
        if (superwallCached && !forceRefresh) {
          const swCache = JSON.parse(superwallCached);
          if (Date.now() - swCache.timestamp < CACHE_DURATION) {
            superwallData = swCache.data;
            needSuperwallFetch = false;
            console.log('Using shared Superwall cache');
          }
        }

        // Fetch Superwall revenue data (for boost calculation)
        const fetchAllSuperwall = async () => {
          let allData = [];
          let offset = 0;
          const limit = 1000;

          while (true) {
            const res = await fetch(
              `${SUPABASE_URL}/rest/v1/superwall_events?select=created_at,proceeds,event_type&order=created_at.asc&limit=${limit}&offset=${offset}`,
              { headers }
            );
            const data = await res.json();
            allData = allData.concat(data);

            if (data.length < limit) break;
            offset += limit;
          }
          return allData;
        };

        adsData = await fetchAllAds();
        console.log('Ads data rows fetched:', adsData.length);

        if (needSuperwallFetch) {
          superwallData = await fetchAllSuperwall();
          console.log('Superwall data rows fetched:', superwallData.length);

          // Save to shared Superwall cache
          localStorage.setItem(SUPERWALL_CACHE_KEY, JSON.stringify({
            timestamp: Date.now(),
            data: superwallData
          }));
        }

        // Save to ads cache (without Superwall data - use shared cache instead)
        const cacheData = {
          timestamp: Date.now(),
          adsData: adsData
        };
        localStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));

        updateSubtitle();
        render();
      } catch (err) {
        alert('Error fetching data: ' + err.message);
      }
    }

    function updateSubtitle() {
      const range = document.getElementById('time-range').value;
      const labels = {
        '24h': 'Last 24 Hours',
        'today': 'Today',
        'yesterday': 'Yesterday',
        '7d': 'Last 7 Days',
        '14d': 'Last 14 Days',
        '30d': 'Last 30 Days'
      };
      document.getElementById('updated').textContent = labels[range] || range;
    }

    function getTimeRange(range) {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      switch (range) {
        case '24h':
          const start24h = new Date(now - 23 * 60 * 60 * 1000);
          start24h.setMinutes(0, 0, 0);
          return { start: start24h, end: now };
        case 'today':
          return { start: today, end: now };
        case 'yesterday':
          const yesterday = new Date(today - 24 * 60 * 60 * 1000);
          return { start: yesterday, end: today };
        case '7d':
          return { start: new Date(today - 6 * 24 * 60 * 60 * 1000), end: now };
        case '14d':
          return { start: new Date(today - 13 * 24 * 60 * 60 * 1000), end: now };
        case '30d':
          return { start: new Date(today - 29 * 24 * 60 * 60 * 1000), end: now };
        default:
          return { start: new Date(now - 23 * 60 * 60 * 1000), end: now };
      }
    }

    function formatValue(value, type) {
      if (value === null || value === undefined || isNaN(value)) {
        return type === 'currency' ? '$0.00' : type === 'percent' ? '0.00%' : '0';
      }

      switch (type) {
        case 'currency':
          return '$' + parseFloat(value).toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        case 'percent':
          return parseFloat(value).toFixed(2) + '%';
        case 'decimal':
          return parseFloat(value).toFixed(2);
        case 'number':
          return parseInt(value).toLocaleString();
        default:
          return value;
      }
    }

    function getPriorPeriodRange(range) {
      // Returns the prior period of equal length for comparison
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());

      switch (range) {
        case '24h':
          const start24h = new Date(now - 23 * 60 * 60 * 1000);
          start24h.setMinutes(0, 0, 0);
          const priorEnd24h = new Date(start24h);
          const priorStart24h = new Date(priorEnd24h - 24 * 60 * 60 * 1000);
          return { start: priorStart24h, end: priorEnd24h };
        case 'today':
          const yesterday = new Date(today - 24 * 60 * 60 * 1000);
          const dayBefore = new Date(today - 48 * 60 * 60 * 1000);
          return { start: dayBefore, end: yesterday };
        case 'yesterday':
          const twoDaysAgo = new Date(today - 48 * 60 * 60 * 1000);
          const threeDaysAgo = new Date(today - 72 * 60 * 60 * 1000);
          return { start: threeDaysAgo, end: twoDaysAgo };
        case '7d':
          return {
            start: new Date(today - 13 * 24 * 60 * 60 * 1000),
            end: new Date(today - 7 * 24 * 60 * 60 * 1000)
          };
        case '14d':
          return {
            start: new Date(today - 27 * 24 * 60 * 60 * 1000),
            end: new Date(today - 14 * 24 * 60 * 60 * 1000)
          };
        case '30d':
          return {
            start: new Date(today - 59 * 24 * 60 * 60 * 1000),
            end: new Date(today - 30 * 24 * 60 * 60 * 1000)
          };
        default:
          const startDefault = new Date(now - 23 * 60 * 60 * 1000);
          const priorEndDefault = new Date(startDefault);
          const priorStartDefault = new Date(priorEndDefault - 24 * 60 * 60 * 1000);
          return { start: priorStartDefault, end: priorEndDefault };
      }
    }

    function calculateMetricsForPeriod(data, start, end) {
      const filtered = data.filter(row => {
        const rowDate = new Date(row.hour_utc);
        return rowDate >= start && rowDate <= end;
      });

      const totals = filtered.reduce((acc, row) => ({
        spend: acc.spend + (parseFloat(row.spend) || 0),
        clicks: acc.clicks + (parseInt(row.clicks) || 0),
        impressions: acc.impressions + (parseInt(row.impressions) || 0),
        conversions: acc.conversions + (parseFloat(row.conversions) || 0),
        conversion_value: acc.conversion_value + (parseFloat(row.conversion_value) || 0),
        link_clicks: acc.link_clicks + (parseInt(row.link_clicks) || 0),
        app_installs: acc.app_installs + (parseInt(row.app_installs) || 0)
      }), { spend: 0, clicks: 0, impressions: 0, conversions: 0, conversion_value: 0, link_clicks: 0, app_installs: 0 });

      return {
        spend: totals.spend,
        cpc: totals.clicks > 0 ? totals.spend / totals.clicks : 0,
        ctr: totals.impressions > 0 ? (totals.clicks / totals.impressions) * 100 : 0,
        cpm: totals.impressions > 0 ? (totals.spend / totals.impressions) * 1000 : 0,
        cpa: totals.conversions > 0 ? totals.spend / totals.conversions : 0,
        roas: totals.spend > 0 ? totals.conversion_value / totals.spend : 0,
        appstore_conv: totals.link_clicks > 0 ? (totals.app_installs / totals.link_clicks) * 100 : 0,
        onboarding_conv: totals.app_installs > 0 ? (totals.conversions / totals.app_installs) * 100 : 0,
        conversions: totals.conversions,
        impressions: totals.impressions,
        clicks: totals.clicks
      };
    }

    function percentChange(current, prior) {
      if (prior === 0) return current > 0 ? 100 : 0;
      return ((current - prior) / prior) * 100;
    }

    function generateInsights(currentMetrics, priorMetrics) {
      const insights = [];

      // Need sufficient data to make comparisons
      if (currentMetrics.spend < 10 || priorMetrics.spend < 10) {
        return insights;
      }

      const ctrChange = percentChange(currentMetrics.ctr, priorMetrics.ctr);
      const cpcChange = percentChange(currentMetrics.cpc, priorMetrics.cpc);
      const cpaChange = percentChange(currentMetrics.cpa, priorMetrics.cpa);
      const spendChange = percentChange(currentMetrics.spend, priorMetrics.spend);

      // Use real ROAS (boosted) if available, otherwise fall back to Meta ROAS
      const currentRoas = currentMetrics.realRoas > 0 ? currentMetrics.realRoas : currentMetrics.roas;
      const priorRoas = priorMetrics.realRoas > 0 ? priorMetrics.realRoas : priorMetrics.roas;
      const roasChange = percentChange(currentRoas, priorRoas);

      const onboardingChange = percentChange(currentMetrics.onboarding_conv, priorMetrics.onboarding_conv);
      const appstoreChange = percentChange(currentMetrics.appstore_conv, priorMetrics.appstore_conv);

      // Rule 1: CTR down + CPC up = Creative fatigue
      if (ctrChange < -15 && cpcChange > 10) {
        insights.push({
          type: 'warning',
          title: 'Creatives may be fatiguing',
          description: `CTR down ${Math.abs(ctrChange).toFixed(0)}% and CPC up ${cpcChange.toFixed(0)}% vs prior period. Consider testing new ad creatives.`
        });
      }

      // Rule 2: Onboarding conversion drops suddenly = potential bug
      if (onboardingChange < -25 && priorMetrics.onboarding_conv > 5) {
        insights.push({
          type: 'danger',
          title: 'Onboarding conversion dropped significantly',
          description: `Down ${Math.abs(onboardingChange).toFixed(0)}% vs prior period. Check for bugs in the onboarding flow or paywall.`
        });
      }

      // Rule 3: App Store conversion drops = listing or audience issue
      if (appstoreChange < -20 && priorMetrics.appstore_conv > 10) {
        insights.push({
          type: 'warning',
          title: 'App Store conversion declined',
          description: `Down ${Math.abs(appstoreChange).toFixed(0)}% vs prior period. Check App Store listing or audience targeting quality.`
        });
      }

      // Rule 4: CPA rising but CTR stable = conversion funnel issue
      if (cpaChange > 20 && Math.abs(ctrChange) < 10) {
        insights.push({
          type: 'warning',
          title: 'CPA rising while CTR is stable',
          description: `CPA up ${cpaChange.toFixed(0)}% but ads performing similarly. Issue is likely in the conversion funnel, not the ads.`
        });
      }

      // Rule 5: Strong ROAS = scale opportunity (use real ROAS)
      if (currentRoas > 2.0 && roasChange > -10) {
        insights.push({
          type: 'success',
          title: 'Strong ROAS - scale opportunity',
          description: `Real ROAS of ${currentRoas.toFixed(2)}x is profitable. Consider increasing spend to capture more volume.`
        });
      }

      // Rule 6: ROAS below 1 = reduce spend (use real ROAS)
      if (currentRoas < 1.0 && currentRoas > 0 && currentMetrics.conversions >= 3) {
        insights.push({
          type: 'danger',
          title: 'ROAS below breakeven',
          description: `Real ROAS of ${currentRoas.toFixed(2)}x means you're losing money. Consider reducing spend or pausing underperformers.`
        });
      }

      // Rule 7: CPC rising significantly with stable CTR = audience saturation
      if (cpcChange > 25 && Math.abs(ctrChange) < 10) {
        insights.push({
          type: 'info',
          title: 'Rising CPCs suggest audience saturation',
          description: `CPC up ${cpcChange.toFixed(0)}% while CTR stable. Consider expanding audience targeting or testing new demographics.`
        });
      }

      // Rule 8: Everything improving = keep going
      if (ctrChange > 10 && cpaChange < -10 && roasChange > 10) {
        insights.push({
          type: 'success',
          title: 'Performance improving across the board',
          description: `CTR up ${ctrChange.toFixed(0)}%, CPA down ${Math.abs(cpaChange).toFixed(0)}%, ROAS up ${roasChange.toFixed(0)}%. Keep current strategy.`
        });
      }

      // Rule 9: High spend with declining efficiency
      if (spendChange > 30 && roasChange < -15) {
        insights.push({
          type: 'warning',
          title: 'Efficiency declining with increased spend',
          description: `Spend up ${spendChange.toFixed(0)}% but ROAS down ${Math.abs(roasChange).toFixed(0)}%. You may be hitting diminishing returns.`
        });
      }

      // Limit to top 2 most important insights
      return insights.slice(0, 2);
    }

    function calculateSuperwallProceeds(start, end) {
      // Filter Superwall data by time range and calculate proceeds by type
      // Use raw UTC time (no correction) to match how ads data is filtered
      const filtered = superwallData.filter(row => {
        const date = new Date(row.created_at);
        return date >= start && date <= end;
      });

      // Sum proceeds from initial purchases (new revenue)
      const newProceeds = filtered
        .filter(row => row.event_type === 'initial_purchase')
        .reduce((sum, row) => sum + (parseFloat(row.proceeds) || 0), 0);

      // Sum proceeds from renewals
      const renewalProceeds = filtered
        .filter(row => row.event_type === 'renewal')
        .reduce((sum, row) => sum + (parseFloat(row.proceeds) || 0), 0);

      const totalProceeds = newProceeds + renewalProceeds;

      return { newProceeds, renewalProceeds, totalProceeds };
    }

    function calculateSuperwallProceedsForHour(hourUtc) {
      // Calculate Superwall proceeds for a specific hour bucket
      // Use raw UTC time (no correction) to match how ads data is filtered
      const hourStart = new Date(hourUtc);
      const hourEnd = new Date(hourStart.getTime() + 60 * 60 * 1000);

      const filtered = superwallData.filter(row => {
        const date = new Date(row.created_at);
        return date >= hourStart && date < hourEnd;
      });

      const newProceeds = filtered
        .filter(row => row.event_type === 'initial_purchase')
        .reduce((sum, row) => sum + (parseFloat(row.proceeds) || 0), 0);

      const renewalProceeds = filtered
        .filter(row => row.event_type === 'renewal')
        .reduce((sum, row) => sum + (parseFloat(row.proceeds) || 0), 0);

      return { newProceeds, renewalProceeds, totalProceeds: newProceeds + renewalProceeds };
    }

    function calculateSuperwallProceedsForDay(dayKey) {
      // Calculate Superwall proceeds for a specific day (YYYY-MM-DD format)
      // Use raw UTC time (no correction) to match how ads data is filtered
      const dayStart = new Date(dayKey + 'T00:00:00Z');
      const dayEnd = new Date(dayKey + 'T23:59:59.999Z');

      const filtered = superwallData.filter(row => {
        const date = new Date(row.created_at);
        return date >= dayStart && date <= dayEnd;
      });

      const newProceeds = filtered
        .filter(row => row.event_type === 'initial_purchase')
        .reduce((sum, row) => sum + (parseFloat(row.proceeds) || 0), 0);

      const renewalProceeds = filtered
        .filter(row => row.event_type === 'renewal')
        .reduce((sum, row) => sum + (parseFloat(row.proceeds) || 0), 0);

      return { newProceeds, renewalProceeds, totalProceeds: newProceeds + renewalProceeds };
    }

    function calculateBoostFactor(superwallProceeds, metaConversionValue) {
      // Boost factor = actual Superwall proceeds / Meta reported conversion value
      if (metaConversionValue <= 0) return 1;
      if (superwallProceeds <= 0) return 1;
      return superwallProceeds / metaConversionValue;
    }

    function renderInsights(insights) {
      const container = document.getElementById('insights-container');

      if (insights.length === 0) {
        container.innerHTML = '';
        return;
      }

      const icons = {
        warning: '!',
        danger: '!',
        success: 'âœ“',
        info: 'i'
      };

      container.innerHTML = insights.map(insight => `
        <div class="insight insight-${insight.type}">
          <div class="insight-icon">${icons[insight.type]}</div>
          <div class="insight-content">
            <div class="insight-title">${insight.title}</div>
            <div class="insight-description">${insight.description}</div>
          </div>
        </div>
      `).join('');
    }

    function render() {
      const range = document.getElementById('time-range').value;
      const timezone = document.getElementById('timezone').value;
      const { start, end } = getTimeRange(range);

      // Filter ads data by time range
      const filteredAds = adsData.filter(row => {
        const rowDate = new Date(row.hour_utc);
        return rowDate >= start && rowDate <= end;
      });

      // Sort by hour descending (most recent first)
      filteredAds.sort((a, b) => new Date(b.hour_utc) - new Date(a.hour_utc));

      // Calculate totals
      const totals = filteredAds.reduce((acc, row) => ({
        spend: acc.spend + (parseFloat(row.spend) || 0),
        clicks: acc.clicks + (parseInt(row.clicks) || 0),
        impressions: acc.impressions + (parseInt(row.impressions) || 0),
        conversions: acc.conversions + (parseFloat(row.conversions) || 0),
        conversion_value: acc.conversion_value + (parseFloat(row.conversion_value) || 0),
        reach: acc.reach + (parseInt(row.reach) || 0),
        link_clicks: acc.link_clicks + (parseInt(row.link_clicks) || 0),
        app_installs: acc.app_installs + (parseInt(row.app_installs) || 0)
      }), { spend: 0, clicks: 0, impressions: 0, conversions: 0, conversion_value: 0, reach: 0, link_clicks: 0, app_installs: 0 });

      // Calculate derived metrics
      const avgCpc = totals.clicks > 0 ? totals.spend / totals.clicks : 0;
      const avgCtr = totals.impressions > 0 ? (totals.clicks / totals.impressions) * 100 : 0;
      const avgCpm = totals.impressions > 0 ? (totals.spend / totals.impressions) * 1000 : 0;
      const avgCpa = totals.conversions > 0 ? totals.spend / totals.conversions : 0;
      const avgRoas = totals.spend > 0 ? totals.conversion_value / totals.spend : 0;
      const cardAppstoreConv = totals.link_clicks > 0 ? (totals.app_installs / totals.link_clicks) * 100 : 0;
      const cardOnboardingConv = totals.app_installs > 0 ? (totals.conversions / totals.app_installs) * 100 : 0;

      // Calculate Superwall proceeds for period
      const swProceeds = calculateSuperwallProceeds(start, end);
      const superwallNewProceeds = swProceeds.newProceeds;
      const superwallRenewalProceeds = swProceeds.renewalProceeds;
      const superwallTotalProceeds = swProceeds.totalProceeds;

      // Real ROAS uses new purchases only (matching index.html)
      const boostFactor = calculateBoostFactor(superwallNewProceeds, totals.conversion_value);
      const realRoas = totals.spend > 0 ? superwallNewProceeds / totals.spend : 0;
      const realCpa = boostFactor > 1 ? avgCpa / boostFactor : avgCpa;
      const boostedConversions = boostFactor > 1 ? totals.conversions * boostFactor : totals.conversions;

      // Update cards
      document.getElementById('total-spend').textContent = '$' + Math.round(totals.spend).toLocaleString();

      // Boost Factor card
      document.getElementById('boost-factor').textContent = boostFactor.toFixed(2) + 'x';

      // CPA card - show boosted if enabled
      const cpaEl = document.getElementById('avg-cpa');
      const cpaLabelEl = document.getElementById('cpa-label');
      if (boostEnabled && boostFactor > 1.1 && superwallNewProceeds > 0) {
        cpaEl.textContent = formatValue(realCpa, 'currency');
        cpaLabelEl.textContent = 'Cost per Result (Boosted)';
      } else {
        cpaEl.textContent = formatValue(avgCpa, 'currency');
        cpaLabelEl.textContent = 'Cost per Result';
      }

      // ROAS card - show boosted if enabled
      const roasEl = document.getElementById('avg-roas');
      const roasLabelEl = document.getElementById('roas-label');
      if (boostEnabled && boostFactor > 1.1 && superwallNewProceeds > 0) {
        roasEl.textContent = realRoas.toFixed(2);
        roasLabelEl.textContent = 'ROAS (Boosted)';
      } else {
        roasEl.textContent = formatValue(avgRoas, 'decimal');
        roasLabelEl.textContent = 'ROAS';
      }

      document.getElementById('avg-ctr').textContent = formatValue(avgCtr, 'percent');
      document.getElementById('avg-cpc').textContent = formatValue(avgCpc, 'currency');

      // Generate insights by comparing to prior period (using boosted metrics)
      const priorRange = getPriorPeriodRange(range);
      const currentMetrics = calculateMetricsForPeriod(adsData, start, end);
      const priorMetrics = calculateMetricsForPeriod(adsData, priorRange.start, priorRange.end);

      // Add boosted ROAS to metrics for insights
      currentMetrics.realRoas = realRoas;
      currentMetrics.boostFactor = boostFactor;

      const priorSwProceeds = calculateSuperwallProceeds(priorRange.start, priorRange.end);
      const priorBoostFactor = calculateBoostFactor(priorSwProceeds.newProceeds, priorMetrics.roas * priorMetrics.spend);
      priorMetrics.realRoas = priorMetrics.spend > 0 ? priorSwProceeds.newProceeds / priorMetrics.spend : 0;
      priorMetrics.boostFactor = priorBoostFactor;

      const insights = generateInsights(currentMetrics, priorMetrics);
      renderInsights(insights);

      // Build table headers
      const headerRow = document.getElementById('ads-table-header');
      headerRow.innerHTML = '';

      visibleColumns.forEach(colKey => {
        const col = ALL_COLUMNS[colKey];
        if (!col) return;
        const th = document.createElement('th');
        // Show "Date" instead of "Hour" when in daily mode
        th.textContent = (colKey === 'hour' && granularity === 'daily') ? 'Date' : col.label;
        headerRow.appendChild(th);
      });

      // Build table rows
      const tbody = document.getElementById('ads-tbody');
      tbody.innerHTML = '';

      // Update table title based on granularity
      document.querySelector('.table-title').textContent = granularity === 'daily' ? 'Daily Ad Metrics' : 'Hourly Ad Metrics';

      // Prepare table data based on granularity
      let tableRows = [];
      if (granularity === 'daily') {
        // Aggregate hourly data into daily buckets for table
        const dailyMap = new Map();
        filteredAds.forEach(row => {
          const date = new Date(row.hour_utc);
          const dayKey = date.toISOString().slice(0, 10); // YYYY-MM-DD

          if (!dailyMap.has(dayKey)) {
            dailyMap.set(dayKey, {
              dayKey: dayKey,
              hour: dayKey + 'T12:00:00Z',
              spend: 0,
              impressions: 0,
              clicks: 0,
              conversions: 0,
              conversion_value: 0,
              link_clicks: 0,
              app_installs: 0,
              reach: 0
            });
          }

          const day = dailyMap.get(dayKey);
          day.spend += parseFloat(row.spend) || 0;
          day.impressions += parseInt(row.impressions) || 0;
          day.clicks += parseInt(row.clicks) || 0;
          day.conversions += parseFloat(row.conversions) || 0;
          day.conversion_value += parseFloat(row.conversion_value) || 0;
          day.link_clicks += parseInt(row.link_clicks) || 0;
          day.app_installs += parseInt(row.app_installs) || 0;
          day.reach += parseInt(row.reach) || 0;
        });

        tableRows = Array.from(dailyMap.values()).map(day => {
          const swProceeds = calculateSuperwallProceedsForDay(day.dayKey);
          return {
            hour: day.hour,
            spend: day.spend,
            impressions: day.impressions,
            clicks: day.clicks,
            ctr: day.impressions > 0 ? (day.clicks / day.impressions) * 100 : 0,
            cpc: day.clicks > 0 ? day.spend / day.clicks : 0,
            cpm: day.impressions > 0 ? (day.spend / day.impressions) * 1000 : 0,
            reach: day.reach,
            frequency: day.reach > 0 ? day.impressions / day.reach : 0,
            link_clicks: day.link_clicks,
            app_installs: day.app_installs,
            conversions: day.conversions,
            conversion_value: day.conversion_value,
            cpa: day.conversions > 0 ? day.spend / day.conversions : 0,
            purchase_roas: day.spend > 0 ? day.conversion_value / day.spend : 0,
            cost_per_install: day.app_installs > 0 ? day.spend / day.app_installs : 0,
            appstore_conv: day.link_clicks > 0 ? (day.app_installs / day.link_clicks) * 100 : 0,
            onboarding_conv: day.app_installs > 0 ? (day.conversions / day.app_installs) * 100 : 0,
            sw_new_proceeds: swProceeds.newProceeds,
            sw_renewal_proceeds: swProceeds.renewalProceeds,
            sw_total_proceeds: swProceeds.totalProceeds,
            real_roas: day.spend > 0 ? swProceeds.newProceeds / day.spend : 0
          };
        });
      } else {
        // Hourly data
        tableRows = filteredAds.map(row => {
          const spend = parseFloat(row.spend) || 0;
          const clicks = parseInt(row.clicks) || 0;
          const impressions = parseInt(row.impressions) || 0;
          const conversions = parseFloat(row.conversions) || 0;
          const appInstalls = parseInt(row.app_installs) || 0;
          const linkClicks = parseInt(row.link_clicks) || 0;
          const costPerInstall = appInstalls > 0 ? spend / appInstalls : 0;
          const appstoreConv = linkClicks > 0 ? (appInstalls / linkClicks) * 100 : 0;
          const onboardingConv = appInstalls > 0 ? (conversions / appInstalls) * 100 : 0;
          const rowSwProceeds = calculateSuperwallProceedsForHour(row.hour_utc);

          return {
            hour: row.hour_utc,
            spend: spend,
            impressions: impressions,
            clicks: clicks,
            ctr: parseFloat(row.ctr) || 0,
            cpc: parseFloat(row.cpc) || 0,
            cpm: parseFloat(row.cpm) || 0,
            reach: parseInt(row.reach) || 0,
            frequency: parseFloat(row.frequency) || 0,
            link_clicks: linkClicks,
            app_installs: appInstalls,
            conversions: conversions,
            conversion_value: parseFloat(row.conversion_value) || 0,
            cpa: conversions > 0 ? spend / conversions : 0,
            purchase_roas: parseFloat(row.purchase_roas) || 0,
            cost_per_install: costPerInstall,
            appstore_conv: appstoreConv,
            onboarding_conv: onboardingConv,
            sw_new_proceeds: rowSwProceeds.newProceeds,
            sw_renewal_proceeds: rowSwProceeds.renewalProceeds,
            sw_total_proceeds: rowSwProceeds.totalProceeds,
            real_roas: spend > 0 ? rowSwProceeds.newProceeds / spend : 0
          };
        });
      }

      tableRows.forEach(rowValues => {
        const tr = document.createElement('tr');

        visibleColumns.forEach(colKey => {
          const col = ALL_COLUMNS[colKey];
          if (!col) return;

          const td = document.createElement('td');

          if (colKey === 'hour') {
            const hourDate = new Date(rowValues.hour);
            if (granularity === 'daily') {
              td.textContent = hourDate.toLocaleString('en-US', {
                timeZone: timezone,
                weekday: 'short',
                month: 'short',
                day: 'numeric'
              });
            } else {
              td.textContent = hourDate.toLocaleString('en-US', {
                timeZone: timezone,
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                hour12: true
              });
            }
          } else {
            td.textContent = formatValue(rowValues[colKey], col.type);
          }

          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });

      // Build totals row
      const totalsRow = document.getElementById('ads-totals-row');
      totalsRow.innerHTML = '';

      // Calculate total conversion rates
      const totalCostPerInstall = totals.app_installs > 0 ? totals.spend / totals.app_installs : 0;
      const totalAppstoreConv = totals.link_clicks > 0 ? (totals.app_installs / totals.link_clicks) * 100 : 0;
      const totalOnboardingConv = totals.app_installs > 0 ? (totals.conversions / totals.app_installs) * 100 : 0;

      const totalValues = {
        hour: 'Total',
        spend: totals.spend,
        impressions: totals.impressions,
        clicks: totals.clicks,
        ctr: avgCtr,
        cpc: avgCpc,
        cpm: avgCpm,
        reach: totals.reach,
        frequency: totals.reach > 0 ? totals.impressions / totals.reach : 0,
        link_clicks: totals.link_clicks,
        app_installs: totals.app_installs,
        conversions: totals.conversions,
        conversion_value: totals.conversion_value,
        cpa: avgCpa,
        purchase_roas: avgRoas,
        cost_per_install: totalCostPerInstall,
        appstore_conv: totalAppstoreConv,
        onboarding_conv: totalOnboardingConv,
        sw_new_proceeds: superwallNewProceeds,
        sw_renewal_proceeds: superwallRenewalProceeds,
        sw_total_proceeds: superwallTotalProceeds,
        real_roas: realRoas
      };

      visibleColumns.forEach(colKey => {
        const col = ALL_COLUMNS[colKey];
        if (!col) return;

        const td = document.createElement('td');

        if (colKey === 'hour') {
          td.textContent = 'Total';
        } else {
          td.textContent = formatValue(totalValues[colKey], col.type);
        }

        totalsRow.appendChild(td);
      });

      // If no data
      if (filteredAds.length === 0) {
        tbody.innerHTML = '';
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = visibleColumns.length;
        td.style.textAlign = 'center';
        td.style.padding = '24px';
        td.style.color = '#6B7280';
        td.textContent = 'No data for this time period';
        tr.appendChild(td);
        tbody.appendChild(tr);
      }

      // Prepare chart data (sorted ascending for chart)
      const chartAds = [...filteredAds].sort((a, b) => new Date(a.hour_utc) - new Date(b.hour_utc));

      if (granularity === 'daily') {
        // Aggregate hourly data into daily buckets
        const dailyMap = new Map();
        chartAds.forEach(row => {
          const date = new Date(row.hour_utc);
          const dayKey = date.toISOString().slice(0, 10); // YYYY-MM-DD

          if (!dailyMap.has(dayKey)) {
            dailyMap.set(dayKey, {
              hour: dayKey + 'T12:00:00Z', // Use noon for display
              spend: 0,
              impressions: 0,
              clicks: 0,
              conversions: 0,
              conversion_value: 0,
              link_clicks: 0,
              app_installs: 0
            });
          }

          const day = dailyMap.get(dayKey);
          day.spend += parseFloat(row.spend) || 0;
          day.impressions += parseInt(row.impressions) || 0;
          day.clicks += parseInt(row.clicks) || 0;
          day.conversions += parseFloat(row.conversions) || 0;
          day.conversion_value += parseFloat(row.conversion_value) || 0;
          day.link_clicks += parseInt(row.link_clicks) || 0;
          day.app_installs += parseInt(row.app_installs) || 0;
        });

        // Convert to chart data with calculated metrics
        chartData = Array.from(dailyMap.entries()).map(([dayKey, day]) => {
          // Calculate Superwall proceeds for this day
          const swProceeds = calculateSuperwallProceedsForDay(dayKey);

          // Calculate boost factor and real CPA for this day
          const dayCpa = day.conversions > 0 ? day.spend / day.conversions : 0;
          const dayBoostFactor = day.conversion_value > 0 ? swProceeds.newProceeds / day.conversion_value : 1;
          const dayRealCpa = dayBoostFactor > 1 ? dayCpa / dayBoostFactor : dayCpa;

          return {
            hour: day.hour,
            spend: day.spend,
            cpm: day.impressions > 0 ? (day.spend / day.impressions) * 1000 : 0,
            cpc: day.clicks > 0 ? day.spend / day.clicks : 0,
            ctr: day.impressions > 0 ? (day.clicks / day.impressions) * 100 : 0,
            cpa: dayCpa,
            conversions: day.conversions,
            conversion_value: day.conversion_value,
            purchase_roas: day.spend > 0 ? day.conversion_value / day.spend : 0,
            appstore_conv: day.link_clicks > 0 ? (day.app_installs / day.link_clicks) * 100 : 0,
            onboarding_conv: day.app_installs > 0 ? (day.conversions / day.app_installs) * 100 : 0,
            impressions: day.impressions,
            clicks: day.clicks,
            app_installs: day.app_installs,
            sw_new_proceeds: swProceeds.newProceeds,
            sw_renewal_proceeds: swProceeds.renewalProceeds,
            sw_total_proceeds: swProceeds.totalProceeds,
            real_roas: day.spend > 0 ? swProceeds.newProceeds / day.spend : 0,
            real_cpa: dayRealCpa
          };
        });
      } else {
        // Hourly data - no aggregation needed
        chartData = chartAds.map(row => {
          const spend = parseFloat(row.spend) || 0;
          const impressions = parseInt(row.impressions) || 0;
          const clicks = parseInt(row.clicks) || 0;
          const conversions = parseFloat(row.conversions) || 0;
          const conversionValue = parseFloat(row.conversion_value) || 0;
          const linkClicks = parseInt(row.link_clicks) || 0;
          const appInstalls = parseInt(row.app_installs) || 0;

          // Calculate Superwall proceeds for this hour
          const swProceeds = calculateSuperwallProceedsForHour(row.hour_utc);

          // Calculate boost factor and real CPA for this hour
          const hourCpa = conversions > 0 ? spend / conversions : 0;
          const hourBoostFactor = conversionValue > 0 ? swProceeds.newProceeds / conversionValue : 1;
          const hourRealCpa = hourBoostFactor > 1 ? hourCpa / hourBoostFactor : hourCpa;

          return {
            hour: row.hour_utc,
            spend: spend,
            cpm: impressions > 0 ? (spend / impressions) * 1000 : 0,
            cpc: clicks > 0 ? spend / clicks : 0,
            ctr: impressions > 0 ? (clicks / impressions) * 100 : 0,
            cpa: hourCpa,
            conversions: conversions,
            conversion_value: conversionValue,
            purchase_roas: spend > 0 ? conversionValue / spend : 0,
            appstore_conv: linkClicks > 0 ? (appInstalls / linkClicks) * 100 : 0,
            onboarding_conv: appInstalls > 0 ? (conversions / appInstalls) * 100 : 0,
            impressions: impressions,
            clicks: clicks,
            app_installs: appInstalls,
            sw_new_proceeds: swProceeds.newProceeds,
            sw_renewal_proceeds: swProceeds.renewalProceeds,
            sw_total_proceeds: swProceeds.totalProceeds,
            real_roas: spend > 0 ? swProceeds.newProceeds / spend : 0,
            real_cpa: hourRealCpa
          };
        });
      }

      updateChart();
    }

    function formatChartLabel(hourUtc) {
      const timezone = document.getElementById('timezone').value;
      const date = new Date(hourUtc);

      if (granularity === 'daily') {
        return date.toLocaleDateString('en-US', {
          timeZone: timezone,
          weekday: 'short',
          month: 'short',
          day: 'numeric'
        });
      }

      const dateStr = date.toLocaleDateString('en-US', {
        timeZone: timezone,
        weekday: 'short'
      });
      const timeStr = date.toLocaleTimeString('en-US', {
        timeZone: timezone,
        hour: 'numeric'
      });
      return `${dateStr}, ${timeStr.toLowerCase()}`;
    }

    // Metric configuration for chart
    const CHART_METRICS = {
      spend: { label: 'Spend', type: 'currency' },
      cpm: { label: 'CPM', type: 'currency' },
      cpc: { label: 'CPC', type: 'currency' },
      ctr: { label: 'CTR', type: 'percent' },
      cpa: { label: 'Cost per Result', type: 'currency' },
      conversions: { label: 'Results', type: 'number' },
      conversion_value: { label: 'Results Value', type: 'currency' },
      purchase_roas: { label: 'Meta ROAS', type: 'decimal' },
      appstore_conv: { label: 'App Store Conv', type: 'percent' },
      onboarding_conv: { label: 'Onboarding Conv', type: 'percent' },
      impressions: { label: 'Impressions', type: 'number' },
      clicks: { label: 'Clicks', type: 'number' },
      app_installs: { label: 'App Installs', type: 'number' },
      sw_new_proceeds: { label: 'SW New $', type: 'currency' },
      sw_renewal_proceeds: { label: 'SW Renewal $', type: 'currency' },
      sw_total_proceeds: { label: 'SW Total $', type: 'currency' },
      real_roas: { label: 'Real ROAS', type: 'decimal' },
      real_cpa: { label: 'Real Cost per Result', type: 'currency' }
    };

    function formatChartValue(value, type) {
      if (value === null || value === undefined || isNaN(value)) return '0';
      switch (type) {
        case 'currency':
          return '$' + value.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });
        case 'percent':
          return value.toFixed(2) + '%';
        case 'decimal':
          return value.toFixed(2);
        case 'number':
          return Math.round(value).toLocaleString();
        default:
          return value.toString();
      }
    }

    function formatChartAxisValue(value, type) {
      if (value === null || value === undefined || isNaN(value)) return '0';
      switch (type) {
        case 'currency':
          if (value >= 1000) return '$' + (value / 1000).toFixed(1) + 'K';
          if (value >= 10) return '$' + Math.round(value);
          if (value >= 1) return '$' + value.toFixed(2);
          if (value >= 0.01) return '$' + value.toFixed(2);
          return '$' + value.toFixed(3);
        case 'percent':
          return value.toFixed(1) + '%';
        case 'decimal':
          return value.toFixed(2);
        case 'number':
          if (value >= 1000) return (value / 1000).toFixed(1) + 'K';
          return Math.round(value).toString();
        default:
          return value.toString();
      }
    }

    function updateChart() {
      const leftMetric = document.getElementById('chart-metric-left').value;
      const rightMetric = document.getElementById('chart-metric-right').value;

      const labels = chartData.map(d => formatChartLabel(d.hour));
      const datasets = [];

      if (leftMetric !== 'none' && CHART_METRICS[leftMetric]) {
        datasets.push({
          label: CHART_METRICS[leftMetric].label,
          data: chartData.map(d => d[leftMetric]),
          borderColor: '#F87171',
          backgroundColor: 'rgba(248, 113, 113, 0.5)',
          borderWidth: 2,
          fill: true,
          tension: 0,
          pointRadius: 0,
          yAxisID: 'y',
          metricType: CHART_METRICS[leftMetric].type
        });
      }

      if (rightMetric !== 'none' && CHART_METRICS[rightMetric]) {
        datasets.push({
          label: CHART_METRICS[rightMetric].label,
          data: chartData.map(d => d[rightMetric]),
          borderColor: '#4ADE80',
          backgroundColor: 'rgba(74, 222, 128, 0.5)',
          borderWidth: 2,
          fill: true,
          tension: 0,
          pointRadius: 0,
          yAxisID: 'y1',
          metricType: CHART_METRICS[rightMetric].type
        });
      }

      const leftType = leftMetric !== 'none' && CHART_METRICS[leftMetric] ? CHART_METRICS[leftMetric].type : null;
      const rightType = rightMetric !== 'none' && CHART_METRICS[rightMetric] ? CHART_METRICS[rightMetric].type : null;

      if (chart) chart.destroy();

      chart = new Chart(document.getElementById('ads-chart'), {
        type: 'line',
        data: { labels, datasets },
        options: {
          animation: false,
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false,
          },
          plugins: {
            legend: { display: false },
            tooltip: {
              enabled: true,
              backgroundColor: 'rgba(31, 41, 55, 0.95)',
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: '#374151',
              borderWidth: 1,
              padding: 12,
              callbacks: {
                title: function(items) {
                  return items[0].label;
                },
                label: function(context) {
                  const metricType = context.dataset.metricType;
                  return `${context.dataset.label}: ${formatChartValue(context.raw, metricType)}`;
                }
              }
            },
          },
          scales: {
            x: {
              ticks: {
                color: '#666666',
                font: { size: 11 },
                maxRotation: 0,
                minRotation: 0,
                autoSkip: true,
                maxTicksLimit: 12,
                callback: function(value, index) {
                  if (index === 0) return '';
                  return this.getLabelForValue(value);
                },
              },
              grid: {
                display: true,
                drawOnChartArea: false,
                drawTicks: true,
                tickLength: 5,
                tickColor: '#666666',
              },
            },
            y: {
              type: 'linear',
              display: leftMetric !== 'none',
              position: 'left',
              ticks: {
                color: '#F87171',
                font: { size: 11 },
                callback: v => formatChartAxisValue(v, leftType),
              },
              grid: {
                color: '#374151',
                drawBorder: false,
              },
            },
            y1: {
              type: 'linear',
              display: rightMetric !== 'none',
              position: 'right',
              ticks: {
                color: '#4ADE80',
                font: { size: 11 },
                callback: v => formatChartAxisValue(v, rightType),
              },
              grid: {
                drawOnChartArea: false,
              },
            },
          },
        },
      });
    }

    function handleTimeRangeChange() {
      const range = document.getElementById('time-range').value;

      // Auto-switch granularity based on time range
      // For 7 days or more, default to daily
      // For 24h, today, yesterday, default to hourly
      if (range === '7d' || range === '14d' || range === '30d') {
        if (granularity === 'hourly') {
          selectGranularity('daily');
        }
      } else if (range === '24h' || range === 'today' || range === 'yesterday') {
        if (granularity === 'daily') {
          selectGranularity('hourly');
        }
      }

      updateSubtitle();
      updateHamburgerMenuSelection();
      render();
    }

    function toggleGranularityDropdown() {
      const menu = document.getElementById('granularity-menu');
      menu.classList.toggle('open');
    }

    function selectGranularity(g) {
      granularity = g;
      document.getElementById('granularity-label').textContent = g === 'hourly' ? 'Hourly' : 'Daily';
      document.getElementById('granularity-menu').classList.remove('open');
      render();
    }

    function toggleNavDropdown() {
      const menu = document.getElementById('nav-dropdown-menu');
      menu.classList.toggle('open');
    }

    function toggleHamburgerMenu() {
      const dropdown = document.getElementById('hamburger-dropdown');
      dropdown.classList.toggle('open');
    }

    function selectTimeRange(value) {
      document.getElementById('time-range').value = value;
      updateHamburgerMenuSelection();
      handleTimeRangeChange();
      toggleHamburgerMenu();
    }

    function selectTimezone(value) {
      document.getElementById('timezone').value = value;
      updateHamburgerMenuSelection();
      render();
      toggleHamburgerMenu();
    }

    function toggleBoost(enabled) {
      boostEnabled = enabled;
      localStorage.setItem('brainrot_boost_enabled', enabled.toString());
      // Sync both checkboxes
      document.getElementById('boost-toggle-desktop').checked = enabled;
      document.getElementById('boost-toggle-mobile').checked = enabled;
      render();
    }

    function initBoostToggle() {
      // Initialize checkboxes from localStorage
      document.getElementById('boost-toggle-desktop').checked = boostEnabled;
      document.getElementById('boost-toggle-mobile').checked = boostEnabled;
    }

    function updateHamburgerMenuSelection() {
      const timeRange = document.getElementById('time-range').value;
      const timezone = document.getElementById('timezone').value;

      document.querySelectorAll('.hamburger-dropdown .menu-option').forEach(opt => {
        opt.classList.remove('selected');
      });

      const timeLabels = {
        '24h': 'Last 24 Hours',
        'today': 'Today',
        'yesterday': 'Yesterday',
        '7d': 'Last 7 Days',
        '14d': 'Last 14 Days',
        '30d': 'Last 30 Days'
      };
      const tzLabels = {
        'America/Los_Angeles': 'PST',
        'America/New_York': 'EST'
      };

      document.querySelectorAll('.hamburger-dropdown .menu-option').forEach(opt => {
        if (opt.textContent === timeLabels[timeRange] || opt.textContent === tzLabels[timezone]) {
          opt.classList.add('selected');
        }
      });
    }

    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      const navDropdown = document.getElementById('nav-dropdown-menu');
      const hamburgerDropdown = document.getElementById('hamburger-dropdown');
      const columnConfigMenu = document.getElementById('column-config-menu');
      const granularityMenu = document.getElementById('granularity-menu');

      if (!e.target.closest('.nav-dropdown')) {
        navDropdown.classList.remove('open');
      }
      if (!e.target.closest('.hamburger-menu')) {
        hamburgerDropdown.classList.remove('open');
      }
      if (!e.target.closest('.column-config')) {
        columnConfigMenu.classList.remove('open');
      }
      if (!e.target.closest('.granularity-dropdown')) {
        granularityMenu.classList.remove('open');
      }
    });

    // Password gate
    const CORRECT_PASSWORD_HASH = '107458b366671198f2e4845cc0a436f532c1e5db47d61c79d2ad11aa419cc980';

    async function hashPassword(password) {
      const encoder = new TextEncoder();
      const data = encoder.encode(password);
      const hashBuffer = await crypto.subtle.digest('SHA-256', data);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    async function checkPassword(event) {
      event.preventDefault();
      const password = document.getElementById('password-input').value;
      const hash = await hashPassword(password);

      if (hash === CORRECT_PASSWORD_HASH) {
        localStorage.setItem('brainrot_auth', hash);
        showDashboard();
      } else {
        document.getElementById('password-error').style.display = 'block';
        document.getElementById('password-input').value = '';
      }
      return false;
    }

    function showDashboard() {
      document.getElementById('password-gate').classList.add('hidden');
      document.getElementById('dashboard-content').classList.add('visible');
      initBoostToggle();
      fetchData();
    }

    // Check if already authenticated
    async function checkAuth() {
      const storedHash = localStorage.getItem('brainrot_auth');
      if (storedHash === CORRECT_PASSWORD_HASH) {
        showDashboard();
      }
    }

    checkAuth();

    // Pull to refresh (mobile only)
    let pullStartY = 0;
    let currentPullDistance = 0;
    let isPulling = false;
    let isRefreshing = false;
    let hasTriggeredHaptic = false;
    const pullThreshold = 60;
    const maxPull = 120;

    const spinner = document.getElementById('ptr-spinner');
    const dashboard = document.getElementById('dashboard-content');

    function haptic(style = 'light') {
      if ('vibrate' in navigator) {
        if (style === 'light') navigator.vibrate(10);
        else if (style === 'medium') navigator.vibrate(20);
        else if (style === 'success') navigator.vibrate([10, 50, 20]);
      }
    }

    document.addEventListener('touchstart', (e) => {
      if (isRefreshing) return;
      if (window.scrollY <= 0) {
        pullStartY = e.touches[0].clientY;
        isPulling = true;
        hasTriggeredHaptic = false;
        currentPullDistance = 0;
        dashboard.style.transition = 'none';
        spinner.style.transition = 'none';
      }
    }, { passive: true });

    document.addEventListener('touchmove', (e) => {
      if (!isPulling || isRefreshing) return;

      const currentY = e.touches[0].clientY;
      const rawPull = currentY - pullStartY;

      if (rawPull > 0 && window.scrollY <= 0) {
        const resistance = Math.max(0.4 - (rawPull / 1000), 0.2);
        currentPullDistance = Math.min(rawPull * resistance, maxPull);

        dashboard.style.transform = `translateY(${currentPullDistance}px)`;
        spinner.style.top = `${currentPullDistance - 30}px`;
        spinner.style.opacity = Math.min(currentPullDistance / pullThreshold, 1);
        spinner.classList.add('visible');

        const rotation = (currentPullDistance / pullThreshold) * 360;
        spinner.querySelector('svg').style.transform = `rotate(${rotation}deg)`;

        if (currentPullDistance >= pullThreshold && !hasTriggeredHaptic) {
          haptic('medium');
          hasTriggeredHaptic = true;
        }
      }
    }, { passive: true });

    document.addEventListener('touchend', () => {
      if (!isPulling) return;

      if (currentPullDistance >= pullThreshold && !isRefreshing) {
        isRefreshing = true;
        haptic('success');

        dashboard.style.transition = 'transform 0.2s ease-out';
        dashboard.style.transform = 'translateY(50px)';
        spinner.style.transition = 'top 0.2s ease-out';
        spinner.style.top = '20px';
        spinner.classList.add('refreshing');

        fetchData(true).then(() => {
          setTimeout(() => {
            dashboard.style.transition = 'transform 0.3s ease-out';
            dashboard.style.transform = 'translateY(0)';
            spinner.style.transition = 'opacity 0.2s ease-out, top 0.3s ease-out';
            spinner.style.opacity = '0';
            spinner.style.top = '-40px';

            setTimeout(() => {
              spinner.classList.remove('visible', 'refreshing');
              isRefreshing = false;
            }, 300);
          }, 500);
        });
      } else {
        dashboard.style.transition = 'transform 0.3s ease-out';
        dashboard.style.transform = 'translateY(0)';
        spinner.style.transition = 'opacity 0.2s ease-out, top 0.3s ease-out';
        spinner.style.opacity = '0';
        spinner.style.top = '-40px';

        setTimeout(() => {
          spinner.classList.remove('visible');
        }, 300);
      }

      isPulling = false;
      currentPullDistance = 0;
    }, { passive: true });

    // Init
    updateHamburgerMenuSelection();
  </script>
</body>
</html>
